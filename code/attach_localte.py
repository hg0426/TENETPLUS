#!/usr/bin/env python
"""
Utility helpers for working with compressed LocalTE columns generated by
`runTE_for_py_python_batch.py --store_local_te`.

The script can:
  * decode the byte-packed LocalTE columns back into Python/NumPy arrays
    (`--action add`, default),
  * drop the encoded columns to slim down a dataset (`--action remove`),
  * or perform both actions and emit separate outputs (`--action both`).

Outputs are written in Parquet format to preserve column schema.
"""

from __future__ import annotations

import argparse
import os
import sys
from typing import Iterable

import numpy as np
import pandas as pd


def _decode_localte(bytes_blob: bytes | memoryview | None, length: int | None, dtype: str | None) -> np.ndarray:
    """Decode a LocalTE byte payload into a float array."""
    if bytes_blob is None or length is None or dtype is None or length == 0:
        return np.array([], dtype=np.float32)
    arr = np.frombuffer(bytes_blob, dtype=dtype, count=int(length))
    # Upcast to float32 for downstream numeric stability while keeping memory modest
    if arr.dtype != np.float32:
        arr = arr.astype(np.float32, copy=False)
    return arr


def _iter_decode(df: pd.DataFrame) -> Iterable[np.ndarray]:
    for row in df.itertuples(index=False):
        yield _decode_localte(row.LocalTE_bytes, row.LocalTE_len, row.LocalTE_dtype)


def decode_localte(df: pd.DataFrame) -> pd.DataFrame:
    """Return a copy of df with a decoded LocalTE column appended."""
    decoded = list(_iter_decode(df))
    df_out = df.copy()
    df_out["LocalTE"] = decoded
    return df_out


def drop_encoded_columns(df: pd.DataFrame) -> pd.DataFrame:
    """Return a copy of df without LocalTE_bytes/len/dtype columns (if present)."""
    cols_to_drop = [c for c in ("LocalTE_bytes", "LocalTE_len", "LocalTE_dtype") if c in df.columns]
    if not cols_to_drop:
        return df.copy()
    return df.drop(columns=cols_to_drop)


def main() -> None:
    parser = argparse.ArgumentParser(description="Decode or prune compressed LocalTE columns.")
    parser.add_argument("--in", dest="input_path", required=True, help="Input Parquet file containing LocalTE_* columns.")
    parser.add_argument("--out", dest="output_path", help="Output Parquet path. Required unless --action both.")
    parser.add_argument(
        "--action",
        choices=("add", "remove", "both"),
        default="add",
        help="add: append decoded LocalTE; remove: drop encoded cols; both: emit two outputs.",
    )
    parser.add_argument("--out_decoded", help="Output path when --action both (decoded with LocalTE column).")
    parser.add_argument("--out_pruned", help="Output path when --action both (encoded columns removed).")
    parser.add_argument("--columns", nargs="*", help="Optional subset of columns to load for faster decoding.")
    args = parser.parse_args()

    load_cols = args.columns
    if load_cols is not None:
        base_cols = {"LocalTE_bytes", "LocalTE_len", "LocalTE_dtype"}
        load_cols = list(set(load_cols) | base_cols)

    try:
        df = pd.read_parquet(args.input_path, columns=load_cols)
    except Exception as exc:
        print(f"Failed to read {args.input_path}: {exc}", file=sys.stderr)
        sys.exit(1)

    if args.action == "add":
        if not args.output_path:
            parser.error("--out is required when --action add")
        df_out = decode_localte(df)
        df_out.to_parquet(args.output_path, index=False)
        print(f"Wrote decoded LocalTE to {args.output_path} (rows={len(df_out):,})")
        return

    if args.action == "remove":
        if not args.output_path:
            parser.error("--out is required when --action remove")
        df_out = drop_encoded_columns(df)
        df_out.to_parquet(args.output_path, index=False)
        print(f"Wrote pruned parquet (no LocalTE_* columns) to {args.output_path} (rows={len(df_out):,})")
        return

    # action == both
    if not args.out_decoded or not args.out_pruned:
        parser.error("--out_decoded and --out_pruned are required when --action both")

    df_decoded = decode_localte(df)
    df_pruned = drop_encoded_columns(df_decoded)
    df_decoded.to_parquet(args.out_decoded, index=False)
    df_pruned.to_parquet(args.out_pruned, index=False)
    print(f"Wrote decoded LocalTE to {args.out_decoded} and pruned table to {args.out_pruned} (rows={len(df):,})")


if __name__ == "__main__":
    main()
